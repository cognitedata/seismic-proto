/**
grpc service for querying seismic data from Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic;

import "types.proto";

// ---

// Requests for metadata and coverage

message SurveyQueryRequest {
    Identifier survey = 1;
    bool list_files = 2;       // should the files from this survey be listed
    bool include_metadata = 3; // should metadata be included in the result
}

message FileQueryRequest {
    Identifier file = 1;
}

message HeaderFileQueryRequest {
    Identifier file = 1;
    bool include_raw_header = 2; // should the raw text header be included
}

message FileCoverageRequest {
    Identifier file = 1;
    CRS crs = 2;                  // [optional] If CRS provided converts coverage to given CRS. If to return original.
    bool in_wkt = 3;              // true to return WKT, false (default) to return geoJson
}

message NavigationPolygonRequest {
    Identifier survey = 1;
}

// ---

// Requests for data filtered by position

/**
Request a single trace from a file by index (inline AND crossline)
**/
message LineTraceQueryRequest {
    Identifier file = 1;
    PositionQuery position = 3;
    bool include_trace_header = 4;
}

/**
Request a single trace from a file by coordinates (x AND y)
**/
message CoordinateTraceQueryRequest {
    Identifier file = 1;
    CoordinateQuery coordinates = 2;
    bool include_trace_header = 4;
}

/**
Request a slice of traces from a file by index (inline OR crossline)
**/
message LineSliceQueryRequest {
    Identifier file = 1;
    LineSelect line = 2;
    bool include_trace_header = 3;
}

/**
Request a slice of traces from a file by coordinates of start and end of an arbitrary line
**/
message GeometrySliceQueryRequest {
    Identifier file = 1;
    Geometry arbitrary_line = 2;
    bool include_trace_header = 3;
}

/**
Request a volume of traces from a file by range of inlines and crosslines
**/
message LineCubeRequest {
    Identifier file = 1;
    LineBasedRectangle rectangle = 2;
    bool include_trace_header = 3;
}

/**
Request a volume of traces from a file with coordinates inside an arbitrary polygon
**/
message GeometryCubeRequest {
    Identifier file = 1;
    Geometry geometry = 2;
    bool include_trace_header = 3;
}

/**
Request a time slice from a file and filter by range of inlines and crosslines
**/
message LineTimeSliceQueryRequest {
    Identifier file = 1;
    LineBasedRectangle rectangle = 2;
    int32 z = 3;             // either time or depth according to the file
}

/**
Request a time slice from a file and filter by coordinates inside an arbitrary polygon
**/
message GeometryTimeSliceQueryRequest {
    Identifier file = 1;
    Geometry geometry = 2;
    int32 z = 3;             // either time or depth according to the file
}


// ---

// Other requests

/**
Filter the area included in the SEGY file by a polygon defined either by spatial coordinates
or by a set of inline and crossline indices
**/
message SegYQueryRequest {
    Identifier file = 1;
    oneof query {
        Geometry polygon = 2;
        LineBasedRectangle lines = 3;
    }
}

/**
Request a pseudo-trace (sequence of values) representing the values for the described path in a file
**/
message PathQueryRequest {
    Identifier file = 1;
    Geometry geometry = 2;
    bool include_trace_header = 3;
}

/**
Request to search surveys inside a polygon or by metadata
**/
message GeometrySearchRequest {
    Geometry polygon = 1;
    MetadataFilter metadata = 2;
    bool over_files = 3;
    bool include_metadata = 3;
}

// ---

// Supporting query message types.

/**
Range of inline and crossline indices defining a 2D region
**/
message LineBasedRectangle {
    PositionQuery top_left = 1;
    PositionQuery bottom_left = 2;
    PositionQuery bottom_right = 3;
    PositionQuery top_right = 4;
}

message MetadataFilter {
    map<string, string> filter = 1;
}

message KeyValueFilter {
    string key = 1;
    string value = 2;
}

/**
Point defined by its x and y coordinates
**/
message CoordinateQuery {
    float x = 1;
    float y = 2;
}

/**
Point defined by its inline and crossline indices
**/
message PositionQuery {
    int32 iline = 1;
    int32 xline = 2;
}

// ---

// Response messages

message AvailableLines {
    repeated int32 lines = 1;
}

// message SearchSurveyListResponse {
//     repeated string name = 1;
// }

message SearchSurveyListResponse {
    repeated SurveyWithFiles surveys = 1;
}

message SurveyWithFiles {
    string id = 1;
    string name = 2;
    map<string, string> metadata = 3;
    repeated File files = 4;
}

message DataCoverageResponse {
    Geometry polygon = 1;
}

message GetSurveyResponse {
    Survey survey = 1;
    repeated File files = 2;
}

message GetFileResponse {
    File file = 1;
    FileStatus status = 2;
    bytes binary_header = 3;
    string text_header = 4;
}

message GetBinaryHeaderResponse {
    BinaryHeader meta = 1;
}

message GetTextHeaderResponse {
    TextHeader meta = 1;
}
