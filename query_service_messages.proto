/**
Messages from the query service of Seismic Datastore in Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic;

import "types.proto";

// ---

// Requests for metadata and coverage

message SurveyQueryRequest {
    Identifier survey = 1;
    bool list_files = 2;       // should the files from this survey be listed
    bool include_metadata = 3; // should metadata be included in the result
}

message FileQueryRequest {
    Identifier file = 1;
}

message HeaderFileQueryRequest {
    Identifier file = 1;
    bool include_raw_header = 2; // should the raw text header be included
}

message FileCoverageRequest {
    Identifier file = 1;
    CRS crs = 2;                  // [optional] If CRS provided converts coverage to given CRS. If to return original.
    bool in_wkt = 3;              // true to return WKT, false (default) to return geoJson
}

message NavigationPolygonRequest {
    Identifier survey = 1;
}

// ---

// Requests for data filtered by position

/**
Request a single trace from a file by index (inline AND crossline)
**/
message LineTraceQueryRequest {
    Identifier file = 1;
    PositionQuery position = 3;
    bool include_trace_header = 4;
}

/**
Request a single trace from a file by coordinates (x AND y). If x and y don't fall in the coordinates of a trace,
will return the closest trace to it.
**/
message CoordinateTraceQueryRequest {
    Identifier file = 1;
    CoordinateQuery coordinates = 2;
    float max_radius = 3; // only return traces if closer than this to the actual point in the file
    bool include_trace_header = 4;
}

/**
Request a slice of traces from a file by index (inline OR crossline)
**/
message LineSliceQueryRequest {
    Identifier file = 1;
    LineSelect line = 2;
    bool include_trace_header = 3;
}

/**
Request a slice of traces from a file by coordinates of start and end of an arbitrary line
**/
message GeometrySliceQueryRequest {
    Identifier file = 1;
    Geometry arbitrary_line = 2;
    bool include_trace_header = 3;
}

/**
Request a volume of traces from a file by range of inlines and crosslines
**/
message LineCubeRequest {
    Identifier file = 1;
    LineBasedRectangle rectangle = 2;
    bool include_trace_header = 3;
}

/**
Request a volume of traces from a file with coordinates inside an arbitrary polygon
**/
message GeometryCubeRequest {
    Identifier file = 1;
    Geometry geometry = 2;
    bool include_trace_header = 3;
}

/**
Request a time slice from a file and filter by range of inlines and crosslines
**/
message LineTimeSliceQueryRequest {
    Identifier file = 1;
    LineBasedRectangle rectangle = 2;
    int32 z = 3;             // either time or depth according to the file
}

/**
Request a time slice from a file and filter by coordinates inside an arbitrary polygon
**/
message GeometryTimeSliceQueryRequest {
    Identifier file = 1;
    Geometry geometry = 2;
    int32 z = 3;             // either time or depth according to the file
}


// ---

// Other requests

/**
Filter the area included in the SEGY file by a polygon defined either by spatial coordinates
or by a set of inline and crossline indices
**/
message SegYQueryRequest {
    Identifier file = 1;
    oneof query {
        Geometry polygon = 2;
        LineBasedRectangle lines = 3;
    }
}

/**
Request a pseudo-trace (sequence of values) representing the values for the described path in a file
**/
message PathQueryRequest {
    Identifier file = 1;
    Geometry geometry = 2;
    bool include_trace_header = 3;
}

/**
Request to search surveys inside a polygon or by metadata
**/
message SearchSurveyRequest {
    Geometry polygon = 1;
    MetadataFilter survey_metadata = 2;
    MetadataFilter file_metadata = 3;
    bool include_metadata = 4;
}

// ---

// Supporting query message types.

/**
Range of inline and crossline indices defining a 2D region
**/
message LineBasedRectangle {
    PositionQuery top_left = 1;
    PositionQuery bottom_left = 2;
    PositionQuery bottom_right = 3;
    PositionQuery top_right = 4;
}

message MetadataFilter {
    map<string, string> filter = 1;
}

message KeyValueFilter {
    string key = 1;
    string value = 2;
}

/**
Point defined by its x and y coordinates
**/
message CoordinateQuery {
    float x = 1;
    float y = 2;
}

/**
Point defined by its inline and crossline indices
**/
message PositionQuery {
    int32 iline = 1;
    int32 xline = 2;
}

// ---

// Response messages

message AvailableLines {
    repeated int32 lines = 1;
}

message SearchSurveyListResponse {
    repeated SurveyWithFiles surveys = 1;
}

message SurveyWithFiles {
    string id = 1;
    string name = 2;
    map<string, string> metadata = 3;
    repeated File files = 4;
}

message DataCoverageResponse {
    Geometry polygon = 1;
}

message GetSurveyResponse {
    Survey survey = 1;
    repeated File files = 2;
}

message GetFileResponse {
    File file = 1;
    string survey_name = 2;
    FileStatus status = 3;
}

message GetBinaryHeaderResponse {
    BinaryHeader meta = 1;
}

message GetTextHeaderResponse {
    TextHeader meta = 1;
}

message TextHeader {
    string file_id = 1;
    string header = 2;
    string raw_header = 3;
}

message BinaryHeader {
    string file_id = 1;
    int32 traces = 2;
    int32 trace_data_type = 3;
    int32 fixed_length_traces = 4;
    int32 segy_revision = 5;
    int32 auxtraces = 6;
    int32 interval = 7;
    int32 interval_original = 8;
    int32 samples = 9;
    int32 samples_original = 10;
    int32 ensemble_fold = 11;
    int32 vertical_sum = 12;
    int32 trace_type_sorting_code = 13;
    int32 sweep_type_code = 14;
    int32 sweep_frequency_start = 15;
    int32 sweep_frequency_end = 16;
    int32 sweep_length = 17;
    int32 sweep_channel = 18;
    int32 sweep_taper_start = 19;
    int32 sweep_taper_end = 20;
    int32 sweep_taper_type = 21;
    int32 correlated_traces = 22;
    int32 amplitude_recovery = 23;
    int32 original_measurement_system = 24;
    int32 impulse_signal_polarity = 25;
    int32 vibratory_polarity_code = 26;
    bytes raw_header = 27;
}

message SegYQueryResponse {
    bytes content = 1;
}
