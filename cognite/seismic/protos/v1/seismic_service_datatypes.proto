/**
Messages that describe data types used by Seismic Datastore in Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic.v1;

import "cognite/seismic/protos/types.proto";

message Coordinate {
    //The x value of the coordinate
    float x = 1;
    //The y value of the coordinate
    float y = 2;
}

message LineSelect {
    oneof direction {
        int32 iline = 1;
        int32 xline = 2;
    }
}

message LineBasedVolume {
    LineDescriptor iline = 1;
    LineDescriptor xline = 2;
    LineDescriptor z = 3;
}

message LineRange {
    LineDescriptor inline = 1;
    LineDescriptor crossline = 2;
}

/**
Used in edit messages to distinguish between an empty map, and a missing map
**/
message OptionalMap {
    map<string, string> data = 1;
}

/**
Representation of the data for a survey
**/
message Survey {
    // Unique identifier for the survey in CDF. The identifier is generated by CDF on creation and not editable.
    string id = 1; 
    // Survey name: Should be a short but recognizable name for the survey. Must be unique within a single CDF tenant, and may be used to refer to the survey in API calls.
    string name = 2; //Survey name
    // Metadata describing the survey with named fields and values. 
    map<string, string> metadata = 3; // @exclude TODO: Augment surveys with a predefined set of fields giving a predictable metadata model and better integration with Discover.
    // External identifier of the survey. The value of this field must be unique among all the surveys in the CDF tenant. It may be used for correlating with systems outside CDF, and for search and retrieval operations later.
    ExternalId external_id = 4;
    string crs = 5; //Coordinate reference system to be used by all members of this survey
    // Manually specify an affine transformation between bin grid coordinates and projected crs coordinates, either using an origin point and the azimuth of the xline axis (P6Transformation) 
    // or by specifying three or more corners of the grid as a list of DoubleTraceCoordinates. This transformation must be valid for all members of this survey.
    SurveyGridTransformation grid_transformation = 6;
    CustomSurveyCoverage custom_coverage = 7; // User-provided coverage override
}

/**
 * A cutout of a seismic store
 */
 message Seismic {
    int64 id = 1;  // The unique internal id of the seismic. It is always present
    string external_id = 2; //The external id of the seismic
    string name = 3; // A non-unique name for the seismic. It is easily editable and is intended to be used as a human-friendly reference. 
    string crs = 4; //The Coordinate Reference System of the seismic
    map<string, string> metadata = 5; //Any custom-defined metadata
    TextHeader text_header = 6; //The text header that corresponds to the seismic
    BinaryHeader binary_header = 7; //The binary header that corresponds to the seismic
    LineRange line_range = 8; // The minimum and maximum extents of the seismic's grid, described in inlines and crosslines.
    VolumeDef volume_def = 9; //The VolumeDef describing the seismic
    int64 partition_id = 10; //The id of the partition the seismic belongs to
    int64 seismicstore_id = 11;  // The id of the seismicstore the seismic is derived from. It is present only if agent has READ access and ALL scope  
    Geometry coverage = 12; //The coverage geometry for the seismic.
}

/**
Represents a seismic store.
**/
message SeismicStore {
    int64 id = 1; //The unique internal id of the seismic store
    string name = 2; // The unique name of the seismic store. Will become non-unique in the future, and `external_id` will become the unique identifier.
    string survey_id = 3; //The survey this seismic store belongs to.
    IngestionSource ingestion_source = 4; // The source of the seismicstore. It indicates how the file was ingested
    map<string, string> metadata = 5; //Any custom-defined metadata
    File ingested_file = 6; // If present, the file this SeismicStore was ingested from
    VolumeDef inline_volume_def = 7; // Volume definition for the store, indexed on inlines. Maps from an inline to all of its valid crosslines.
    VolumeDef crossline_volume_def = 8; // Volume definition for the store, indexed on crosslines. Maps from a crossline to all of its valid inlines
    TextHeader text_header = 9; //If present, the text header for this seismic store
    BinaryHeader binary_header = 10; //If present, the binary header for this seismic store
    // Tenant specific name for the storage facility the trace data are stored in. If empty, it is stored in an unspecified trace store.
    // While support for multiple storage backends per store is planned, this is not currently offered.
    repeated string storage_tier_name = 11;
    Geometry coverage = 12; //If present, the coverage geometry for this seismic store
}

/**
Represents partitions, used for granular access control
**/
message Partition {
    //The unique internal id for this partition
    int64 id = 1;
    //The external id of the partition
    string external_id = 2;
    //The human-friendly name for this partition
    string name = 3;
    //The list of seismics that belong to this partition
    repeated Seismic seismics = 4;
}

/**
VolumeDef is a simple, versioned, flexible format for describing which grid points of a seismic volume contain data.

The grid is described per line. Each line contains a series of descriptors that specify the points on the axis perpendicular to the line. 
For example, a volumedef that is indexed as inline-major will use inline numbers as keys in the lines object, and have descriptors with crossline numbers.

For more information refer to [VolumeDef schema](https://cognite-seismic-sdk.readthedocs-hosted.com/en/latest/volumedef.html#volumedef-overview "SDK documentation")

**/
message VolumeDef {
    string json = 1;  // Uses the Volume Definition schema
}

/**
Used to identify zero or one objects that may have an external id 
**/
message Identifier {
    oneof handle {
        int64 id = 1;
        string external_id = 2;
    }
}

/**
Used to identify any number of objects, intended for any plural Read* endpoints. Set* endpoints should use Identifier.

Can search by id, name, or prefix.
**/
message SearchSpec {
    oneof findby {
        int64 id = 1;
        string id_string = 6; // Surveys and files must have string format ids. Other objects can't use this.
        // External ids only exist for partitions and seismics.
        string external_id = 2;  // Exact match required
        string external_id_substring = 3;
        // Names exist for everything
        string name = 4;  // An exact string match is required
        string name_substring = 5;  // Searches for names having this substring.
    }
}

message CoverageSpec {
    // If crs is not specified (aka is blank), uses default crs from file
    string crs = 1;
    enum Format {
        WKT = 0;
        GEOJSON = 1;
    }
    Format format = 2;
}
/**
A representation of text headers used to create or edit existing headers.
**/
message TextHeader {
    string file_id = 1;
    string header = 2; // The text content of the header
    string raw_header = 3; // The raw bytes of a header as a string
}
/**
A representation of binary headers used to create or edit existing headers. BinaryHeader FIELDS contains the list of valid fields. to set after the object is constructed.
**/
message BinaryHeader {
    string file_id = 1;
    int32 traces = 2;
    int32 trace_data_type = 3;
    int32 fixed_length_traces = 4;
    int32 segy_revision = 5;
    int32 auxtraces = 6;
    int32 interval = 7;
    int32 interval_original = 8;
    int32 samples = 9;
    int32 samples_original = 10;
    int32 ensemble_fold = 11;
    int32 vertical_sum = 12;
    int32 trace_type_sorting_code = 13;
    int32 sweep_type_code = 14;
    int32 sweep_frequency_start = 15;
    int32 sweep_frequency_end = 16;
    int32 sweep_length = 17;
    int32 sweep_channel = 18;
    int32 sweep_taper_start = 19;
    int32 sweep_taper_end = 20;
    int32 sweep_taper_type = 21;
    int32 correlated_traces = 22;
    int32 amplitude_recovery = 23;
    int32 original_measurement_system = 24;
    int32 impulse_signal_polarity = 25;
    int32 vibratory_polarity_code = 26;
    bytes raw_header = 27;
}


message TraceExtent {
    int32 xline = 1;
    int32 iline = 2;
    LineDescriptor z = 3;
}

message LineBasedExtent {
    repeated TraceExtent extents = 1;
}
