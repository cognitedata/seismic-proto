/**
Messages that describe data types used by Seismic Datastore in Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic.v1;

import "cognite/seismic/protos/types.proto";

message Coordinate {
    //The x value of the coordinate
    float x = 1;
    //The y value of the coordinate
    float y = 2;
}

message LineSelect {
    oneof direction {
        int32 iline = 1;
        int32 xline = 2;
    }
}

message LineBasedVolume {
    LineDescriptor iline = 1;
    LineDescriptor xline = 2;
    LineDescriptor z = 3;
}

message LineRange {
    LineDescriptor inline = 1;
    LineDescriptor crossline = 2;
}

/**
Used in edit messages to distinguish between an empty map, and a missing map
**/
message OptionalMap {
    map<string, string> data = 1;
}

/**
Representation of the data for a survey
**/
message Survey {
    string id = 1;
    string name = 2;
    map<string, string> metadata = 3;
    ExternalId external_id = 4;
    string crs = 5;
    SurveyGridTransformation grid_transformation = 6;
}

/**
 * A cutout of a seismic store
 */
 message Seismic {
    int64 id = 1;  // The unique internal id of the seismic. It is always present
    string external_id = 2; //The external id of the seismic
    string name = 3; // A non-unique name for the seismic. It is easily editable and is intended to be used as a human-friendly reference. 
    string crs = 4; //The Coordinate Reference System of the seismic
    map<string, string> metadata = 5; //Any custom-defined metadata
    TextHeader text_header = 6; //The text header that corresponds to the seismic
    BinaryHeader binary_header = 7; //The binary header that corresponds to the seismic
    LineRange line_range = 8; // The minimum and maximum extents of the seismic's grid, described in inlines and crosslines.
    VolumeDef volume_def = 9; //The VolumeDef describing the seismic
    int64 partition_id = 10; //The id of the partition the seismic belongs to
    int64 seismicstore_id = 11;  // The id of the seismicstore the seismic is derived from. It is present only if agent has READ access and ALL scope  
    Geometry coverage = 12; //The coverage geometry for the seismic.
}

/**
Represents a seismic store.
**/
message SeismicStore {
    int64 id = 1; //The unique internal id of the seismic store
    string name = 2; // The unique name of the seismic store. Will be changed to external-id in the future
    string survey_id = 3; //The survey this seismic store belongs to.
    IngestionSource ingestion_source = 4; // The source of the seismicstore. It indicates how the file was ingested
    map<string, string> metadata = 5; //Any custom-defined metadata
    File ingested_file = 6; // If present, the file this SeismicStore was ingested from
    VolumeDef inline_volume_def = 7; // Volume definition for the store, indexed on inlines. Maps from an inline to all of its valid crosslines.
    VolumeDef crossline_volume_def = 8; // Volume definition for the store, indexed on crosslines. Maps from a crossline to all of its valid inlines
    TextHeader text_header = 9; //If present, the text header for this seismic store
    BinaryHeader binary_header = 10; //If present, the binary header for this seismic store
    // Tenant specific name for the storage facility the trace data are stored in. If empty, it is stored in an unspecified trace store.
    // While support for multiple storage backends per store is planned, this is not currently offered.
    repeated string storage_tier_name = 11;
    Geometry coverage = 12; //If present, the coverage geometry for this seismic store
}

/**
Represents partitions, used for granular access control
**/
message Partition {
    int64 id = 1;
    string external_id = 2;
    string name = 3;
    repeated Seismic seismics = 4;
}

/**
Specifies the volume "shape"

The json data describes a map from an inline value to all of its valid crosslines. The valid crosslines can
be defined by a combination of value lists, or ranges (defining a start and end crossline and a step value).

Example:

{
    "lines": {
        "1": [{"range": [20, 24, 1]}],
        "2": [{"range": [20, 22, 1]}, "list": [23, 24]]
    },
    "version": 100
 }
**/
message VolumeDef {
    string json = 1;  // Uses the Volume Definition schema
}

/**
Used to identify zero or one objects that may have an external id 
**/
message Identifier {
    oneof handle {
        int64 id = 1;
        string external_id = 2;
    }
}

/**
Used to identify any number of objects, intended for any plural Read* endpoints. Set* endpoints should use Identifier.

Can search by id, name, or prefix.
**/
message SearchSpec {
    oneof findby {
        int64 id = 1;
        string id_string = 6; // Surveys and files must have string format ids. Other objects can't use this.
        // External ids only exist for partitions and seismics.
        string external_id = 2;  // Exact match required
        string external_id_substring = 3;
        // Names exist for everything
        string name = 4;  // An exact string match is required
        string name_substring = 5;  // Searches for names having this substring.
    }
}

message CoverageSpec {
    // If crs is not specified (aka is blank), uses default crs from file
    string crs = 1;
    enum Format {
        WKT = 0;
        GEOJSON = 1;
    }
    Format format = 2;
}

message TextHeader {
    string file_id = 1;
    string header = 2;
    string raw_header = 3;
}
/**
A representation of binary headers used to create or edit existing headers. BinaryHeader FIELDS contains the list of valid fields. to set after the object is constructed.
**/
message BinaryHeader {
    string file_id = 1;
    int32 traces = 2;
    int32 trace_data_type = 3;
    int32 fixed_length_traces = 4;
    int32 segy_revision = 5;
    int32 auxtraces = 6;
    int32 interval = 7;
    int32 interval_original = 8;
    int32 samples = 9;
    int32 samples_original = 10;
    int32 ensemble_fold = 11;
    int32 vertical_sum = 12;
    int32 trace_type_sorting_code = 13;
    int32 sweep_type_code = 14;
    int32 sweep_frequency_start = 15;
    int32 sweep_frequency_end = 16;
    int32 sweep_length = 17;
    int32 sweep_channel = 18;
    int32 sweep_taper_start = 19;
    int32 sweep_taper_end = 20;
    int32 sweep_taper_type = 21;
    int32 correlated_traces = 22;
    int32 amplitude_recovery = 23;
    int32 original_measurement_system = 24;
    int32 impulse_signal_polarity = 25;
    int32 vibratory_polarity_code = 26;
    bytes raw_header = 27;
}


message TraceExtent {
    int32 xline = 1;
    int32 iline = 2;
    LineDescriptor z = 3;
}

message LineBasedExtent {
    repeated TraceExtent extents = 1;
}
