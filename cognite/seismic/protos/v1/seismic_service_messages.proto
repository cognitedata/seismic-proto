/**
Messages that describe requests/responses from the Seismic Datastore in Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic.v1;

import "google/protobuf/wrappers.proto";
import "google/protobuf/timestamp.proto";
import "cognite/seismic/protos/v1/seismic_service_datatypes.proto";
import "cognite/seismic/protos/types.proto";

// ---

// Iteration: 9 <- increment this number when you modify this file
// (╯°□°)╯︵ ┻━┻

/**
    Surveys
**/

message CreateSurveyRequest {
    // Short descriptive name
    string name = 1;
    // Key-value pairs of metadata for the survey.
    map<string, string> metadata = 2;
    // Identifier for correlation with systems outside CDF
    ExternalId external_id = 3;
    string crs = 4; // CRS used by all members
    SurveyGridTransformation grid_transformation = 5; // Optional
    CustomSurveyCoverage custom_coverage = 6; // [optional] Customer-provided survey coverage
}

message SearchSurveysRequest {
    repeated SearchSpec surveys = 1; // Optional identifier of the survey. If empty, retrieve all accessible surveys
    bool list_seismic_ids = 2;           // set to true to list the survey's seismics in the response (default: false)
    bool list_seismic_store_ids = 3;  // Set to true to list the survey's seismic stores in the response. Only tenant users can see this.
    bool include_metadata = 4;       // set to true to include survey metadata in the response (default: false)
    CoverageParameters include_coverage = 5;    // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 9;    // set this field to include coverage in the response (default: No coverage)
    bool include_grid_transformation = 6;    // set this field to include the manually specified grid transformation in the response (default: false)
    bool include_custom_coverage = 7;    // set this field to include the customer-provided survey coverage in the response
    // Requests that a coverage geometry from a particular source is returned in the SearchSurveysResponse.
    // If this field is specified, the coverage parameters in the include_coverage field must also be set.
    // Note that this is independent from the custom coverage returned as part of the survey.
    // If no coverage source is provided, but the coverage parameters are provided, the coverage geometry will be fetched from the custom coverage if one has been provided, and the calculated coverage in other cases.
    SurveyCoverageSource coverage_source = 8;
}

message SearchSurveyResponse {
    Survey survey = 1;
    repeated string seismic_ids = 2;  // Optionally present
    repeated string seismic_store_ids = 3;  // Optionally present
    Geometry coverage = 4;  // Optionally present
    SurveyCoverageSource coverage_source = 5;
}

message EditSurveyRequest {
    Identifier survey = 1;
    OptionalMap metadata = 2;  // The existing metadata will be replaced with this metadata.
    ExternalId external_id = 3;
    CRS crs = 4; // CRS used by all members
    SurveyGridTransformation grid_transformation = 5; // Optional
    CustomSurveyCoverage custom_coverage = 6; // Optional
    google.protobuf.StringValue new_name = 7; // If provided, the new name of the survey
}

message DeleteSurveyRequest {
    Identifier survey = 1;
}

message DeleteSurveyResponse {
    bool success = 1;
}

/**
    Source Files
**/

message RegisterSourceSegyFileRequest {
    Identifier survey = 1;                     // [required] The survey this source file belongs to
    string path = 2;                           // [required] Path including protocol, bucket, directory structure, and file name. Example: "gs://cognite-seismic-eu/samples/DN1302M03R16_MERGED_KPSDM_00-32_DEG_T.sgy"
    ExternalId external_id = 3;                // [optional] An external identifier - matches service contract field
    map<string, string> metadata = 4;          // [optional] Any custom-defined metadata
    CRS crs = 5;                               // [required] Official name of the CRS used. Example: "EPSG:23031"
    SegyOverrides overrides = 6;               // [optional] Overrides for the source file
    repeated TraceHeaderField key_fields = 7;  // [optional] The trace header fields that will be used as keys for indexing
    Dimensions dimensions = 8;                 // [required] File data dimensionality, either 2D or 3D
}

message RegisterSourceSegyFileResponse {
    SourceSegyFile file = 1;
}

message EditSourceSegyFileRequest {
    Identifier file = 1;                       // [required] The registered source file to edit
    google.protobuf.StringValue path = 2;      // [optional] Path including protocol, bucket, directory structure, and file name. Example: "gs://cognite-seismic-eu/samples/DN1302M03R16_MERGED_KPSDM_00-32_DEG_T.sgy"
    ExternalId external_id = 3;                // [optional] An external identifier - matches service contract field
    map<string, string> metadata = 4;          // [optional] Any custom-defined metadata
    CRS crs = 5;                               // [optional] Official name of the CRS used. Example: "EPSG:23031"
    SegyOverrides overrides = 6;               // [optional] Overrides for the source file
    repeated TraceHeaderField key_fields = 7;  // [optional] The trace header fields that will be used as keys for indexing
    Dimensions dimensions = 8;                 // [optional] File data dimensionality, either 2D or 3D
}

message EditSourceSegyFileResponse {
    SourceSegyFile file = 1;
}

message UnregisterSourceSegyFileRequest {
    Identifier file = 1;                       // [required] The file to unregister
}

message UnregisterSourceSegyFileResponse {}

/**
    Seismics
**/

message CreateSeismicRequest {
    string name = 1;  // optional
    string external_id = 2;  // not optional
    Identifier partition = 3;
    int64 seismic_store_id = 4;
    // Defines the portion of the tracestore volume to limit the new seismic to 
    oneof volume {
        VolumeDef volume_def = 5;  // Define the volume as VolumeDef format
        Geometry geometry = 7;  // Defines the volume as WKT or GeoJson
        bool empty = 10;  // If true, will create a seismic with an empty cutout
        Seismic2dExtent two_dee_extent = 12;   // only valid if the seismic is 2D
        Seismic3dExtent three_dee_extent = 13; // only valid if the seismic is 3D
    }
    OptionalMap metadata = 6;
    TextHeader text_header = 8;  // Optionally set a custom text header
    BinaryHeader binary_header = 9;  // Optionally set a custom binary header
    bool copy_metadata = 11;  // If true, copy the metadata from the source seismic store.
}

message SearchSeismicsRequest {
    oneof findby {
        SearchSpec survey = 1;
        SearchSpec seismic = 2;
        SearchSpec partition = 3;  // Can only search on partitions you can see.
    }
    bool include_text_header = 4;
    bool include_binary_header = 5;
    bool include_line_range = 6;
    bool include_volume_definition = 7;  // If true, include the volume definition blob
    bool include_cutout = 12;            // If true, include the cutout specification the seismicstore was created with
    bool include_extent = 13;            // If true, include a description of the included traces
    bool include_seismic_store = 8;      // If true, include info on the backing seismicstore. Must be data manager.
    bool include_partition = 9;          // If true, include info on the partition. Must be data manager.\
    bool include_coverage = 10;          // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 11;          // If specified, requests coverage as well.
}

message EditSeismicRequest {
    Identifier seismic = 1;
    google.protobuf.StringValue name = 2;
    OptionalMap metadata = 3;
    TextHeader text_header = 4;  // Replaces the existing text header, if specified
    BinaryHeader binary_header = 5; // Replaces the existing binary header, if specified
}

message DeleteSeismicRequest {
    Identifier seismic = 1;
}

message DeleteSeismicResponse {
    bool succeeded = 1;
}

message SearchSeismicStoresRequest {
    oneof findby {
        SearchSpec seismic_store = 1;
        SearchSpec survey = 6;
    }
    bool include_file_info = 2;  // If true, include File information in the response
    bool include_volume_definitions = 3; // If true, includes inline/crossline volume definitions for store
    bool include_extent = 8; // If true, include a description of the traces contained in the seismicstore
    bool include_headers = 5; // if true, include text and binary headers in the response
    bool include_coverage = 4; // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 7; // If specified, include coverage
}

message EditSeismicStoreRequest {
    int64 seismic_store_id = 1; // Deprecated. Use `identifier` instead.
    google.protobuf.StringValue name = 2; // If not null will change the seismic store name
    OptionalMap metadata = 3; // If not null, will replace the seismic store metadata
    Identifier seismic_store = 4; // Uniquely identifies one seismic store
    google.protobuf.StringValue external_id = 5; // If not null, will attempt to change the seismic store external id. Can fail if the new external id is not unique.
}

message DeleteSeismicStoreRequest {
    Identifier seismic_store = 1;
}

message DeleteSeismicStoreResponse {
    bool succeeded = 1;
}

/**

    Partitions

**/

message CreatePartitionRequest {
    string name = 1;  // optional name
    string external_id = 2;  // not optional externalid
}

message SearchPartitionsRequest {
    SearchSpec partitions = 1;
}

message EditPartitionRequest {
    Identifier partition = 1;  // Must uniquely identify a partition
    string new_name = 2;
}

message DeletePartitionRequest {
    Identifier partition = 1;
}

message DeletePartitionResponse {
    bool success = 1;
}

/**
    Trace querying
**/

message VolumeRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;  // Need to be a data manager or tenant user, not 3rd party, to access by tracestore
    }
    oneof filter {
        LineBasedVolume volume = 3;
        GeometryBasedVolume geometry = 5;
    }
    bool include_trace_header = 4;
}

message GeometryBasedVolume {
    Geometry geometry = 1;
    InterpolationMethod interpolation_method = 2; // Required if the geometry describes a line, otherwise ignored
    LineDescriptor z_range = 3;
}

message VolumeBoundsResponse {
    int32 trace_size_bytes = 1; // The size in bytes of one Trace message
    int32 num_traces = 2;       // The number of traces returned
    int32 sample_count = 5;     // The number of samples per trace
    string crs = 3;             // CRS of the returned trace coordinates
    // Upper and lower bounds and step sizes in each direction for the returned traces.
    // Null if the result is empty. The iline and xline fields will be null for a line-like geometry.
    LineBasedVolume bounds = 4;
}

message StreamTracesRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;  // Need to be a data manager or tenant user, not 3rd party, to access by tracestore
    }
    oneof filter {
        Seismic2dExtent two_dee_extent = 3;   // only valid if the queried object is 2D
        Seismic3dExtent three_dee_extent = 4; // only valid if the queried object is 3D
        GeometryFilter geometry = 5;
    }
    LineDescriptor depth_range = 6;
}

message SegYSeismicRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;
    }
    oneof query {
        Geometry polygon = 3;
        LineBasedRectangle lines = 4;
    }
}

message SegYSeismicResponse {
    bytes content = 1;
}

/**

    File operations

**/

// Used to search files by id, extid, extid substring, name, name substring
message SearchFilesRequest {
    SearchSpec spec = 1;
}

message SearchJobStatusRequest {
    oneof id {
        string job_id = 1;
        string file_uuid = 2;
    }
    JobStatus status = 3;
    google.protobuf.StringValue target_storage_tier_name = 4;
    google.protobuf.Timestamp started_before = 5;
    google.protobuf.Timestamp started_after = 6;
    google.protobuf.Timestamp updated_before = 7;
    google.protobuf.Timestamp updated_after = 8;
}

message JobStatusResponse {
    string job_id = 1;
    string file_uuid = 2;
    JobStatus status = 3;
    google.protobuf.Timestamp started_at = 4;
    google.protobuf.Timestamp updated_at = 5;
    google.protobuf.StringValue target_storage_tier_name = 6;
    repeated IngestionLog logs = 7;
}

message IngestionLog {
    google.protobuf.Timestamp timestamp = 1;
    string log_line = 2;
}
