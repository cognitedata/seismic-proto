/**
Messages that describe requests/responses from the Seismic Datastore in Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic.v1;

import "google/protobuf/wrappers.proto";
import "cognite/seismic/protos/v1/seismic_service_datatypes.proto";
import "cognite/seismic/protos/types.proto";

// ---

// Iteration: 8 <- increment this number when you modify this file
// (╯°□°)╯︵ ┻━┻

/**
    Surveys
**/

message CreateSurveyRequest {
    // Short descriptive name
    string name = 1;
    // Key-value pairs of metadata for the survey.
    map<string, string> metadata = 2;
    // Identifier for correlation with systems outside CDF
    ExternalId external_id = 3;
    string crs = 4; // CRS used by all members
    SurveyGridTransformation grid_transformation = 5; // Optional
    CustomSurveyCoverage custom_coverage = 6; // [optional] Customer-provided survey coverage
}

message SearchSurveysRequest {
    repeated SearchSpec surveys = 1; // Optional identifier of the survey. If empty, retrieve all accessible surveys
    bool list_seismic_ids = 2;           // set to true to list the survey's seismics in the response (default: false)
    bool list_seismic_store_ids = 3;  // Set to true to list the survey's seismic stores in the response. Only tenant users can see this.
    bool include_metadata = 4;       // set to true to include survey metadata in the response (default: false)
    CoverageParameters include_coverage = 5;    // set this field to include coverage in the response (default: false)
    bool include_grid_transformation = 6;    // set this field to include the manually specified grid transformation in the response (default: false)
    bool include_custom_coverage = 7;    // set this field to include the customer-provided survey coverage in the response
    // Requests that a coverage geometry from a particular source is returned in the SearchSurveysResponse.
    // If this field is specified, the coverage parameters in the include_coverage field must also be set.
    // Note that this is independent from the custom coverage returned as part of the survey.
    // If no coverage source is provided, but the coverage parameters are provided, the coverage geometry will be fetched from the custom coverage if one has been provided, and the calculated coverage in other cases.
    SurveyCoverageSource coverage_source = 8;
}

message SearchSurveyResponse {
    Survey survey = 1;
    repeated string seismic_ids = 2;  // Optionally present
    repeated string seismic_store_ids = 3;  // Optionally present
    Geometry coverage = 4;  // Optionally present
    SurveyCoverageSource coverage_source = 5;
}

message EditSurveyRequest {
    Identifier survey = 1;
    OptionalMap metadata = 2;  // The existing metadata will be replaced with this metadata.
    ExternalId external_id = 3;
    CRS crs = 4; // CRS used by all members
    SurveyGridTransformation grid_transformation = 5; // Optional
    CustomSurveyCoverage custom_coverage = 6; // Optional
    google.protobuf.StringValue new_name = 7; // If provided, the new name of the survey
}

message DeleteSurveyRequest {
    Identifier survey = 1;
}

message DeleteSurveyResponse {
    bool success = 1;
}

/**
    Seismics
**/

message CreateSeismicRequest {
    string name = 1;  // optional
    string external_id = 2;  // not optional
    Identifier partition = 3;
    int64 seismic_store_id = 4;
    // Defines the portion of the tracestore volume to limit the new seismic to 
    oneof volume {
        VolumeDef volume_def = 5;  // Define the volume as VolumeDef format
        Geometry geometry = 7;  // Defines the volume as WKT or GeoJson
        bool empty = 10;  // If true, will create a seismic with an empty cutout
    }
    OptionalMap metadata = 6;
    TextHeader text_header = 8;  // Optionally set a custom text header
    BinaryHeader binary_header = 9;  // Optionally set a custom binary header
    bool copy_metadata = 11;  // If true, copy the metadata from the source seismic store.
}

message SearchSeismicsRequest {
    oneof findby {
        SearchSpec survey = 1;
        SearchSpec seismic = 2;
        SearchSpec partition = 3;  // Can only search on partitions you can see.
    }
    bool include_text_header = 4;
    bool include_binary_header = 5;
    bool include_line_range = 6;
    bool include_volume_definition = 7;  // If true, include the volume definition blob
    bool include_seismic_store = 8; // If true, include info on the backing seismicstore. Must be data manager.
    bool include_partition = 9; // If true, include info on the partition. Must be data manager.\
    bool include_coverage = 10; // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 11; // If specified, requests coverage as well.
}

message EditSeismicRequest {
    Identifier seismic = 1;
    google.protobuf.StringValue name = 2;
    OptionalMap metadata = 3;
    TextHeader text_header = 4;  // Replaces the existing text header, if specified
    BinaryHeader binary_header = 5; // Replaces the existing binary header, if specified
}

message DeleteSeismicRequest {
    Identifier seismic = 1;
}

message DeleteSeismicResponse {
    bool succeeded = 1;
}

message SearchSeismicStoresRequest {
    oneof findby {
        SearchSpec seismic_store = 1;
        SearchSpec survey = 6;
    }
    bool include_file_info = 2;  // If true, include File information in the response
    bool include_volume_definitions = 3; // If true, includes inline/crossline volume definitions for store
    bool include_headers = 5; // if true, include text and binary headers in the response
    bool include_coverage = 4; // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 7; // If specified, include coverage
}

message EditSeismicStoreRequest {
    int64 seismic_store_id = 1; // Deprecated. Use `identifier` instead.
    google.protobuf.StringValue name = 2; // If not null will change the seismic store name
    OptionalMap metadata = 3; // If not null, will replace the seismic store metadata
    Identifier seismic_store = 4; // Uniquely identifies one seismic store
    google.protobuf.StringValue external_id = 5; // If not null, will attempt to change the seismic store external id. Can fail if the new external id is not unique.
}

message DeleteSeismicStoreRequest {
    Identifier seismic_store = 1;
}

message DeleteSeismicStoreResponse {
    bool succeeded = 1;
}

/**

    Partitions

**/

message CreatePartitionRequest {
    string name = 1;  // optional name
    string external_id = 2;  // not optional externalid
}

message SearchPartitionsRequest {
    SearchSpec partitions = 1;
}

message EditPartitionRequest {
    Identifier partition = 1;  // Must uniquely identify a partition
    string new_name = 2;
}

message DeletePartitionRequest {
    Identifier partition = 1;
}

message DeletePartitionResponse {
    bool success = 1;
}

/**
    Trace querying
**/

message VolumeRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;  // Need to be a data manager or tenant user, not 3rd party, to access by tracestore
    }
    oneof filter {
        LineBasedVolume volume = 3;
        GeometryBasedVolume geometry = 5;
    }
    bool include_trace_header = 4;
}

message GeometryBasedVolume {
    Geometry geometry = 1;
    InterpolationMethod interpolation_method = 2; // Required if the geometry describes a line, otherwise ignored
    LineDescriptor z_range = 3;
}

message SegYSeismicRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;
    }
    oneof query {
        Geometry polygon = 3;
        LineBasedRectangle lines = 4;
    }
}

message SegYSeismicResponse {
    bytes content = 1;
}

/**

    File operations

**/

// Used to search files by id, extid, extid substring, name, name substring
message SearchFilesRequest {
    SearchSpec spec = 1;
}

message RegisterFileRequest {
    Identifier survey = 1;             // [required] Either name or id of a survey previously registered with /RegisterSurvey
    string path = 2;                   // [required if file is not synthetic] Path including protocol, bucket and directory structure. Example: "gs://cognite-seismic-eu/samples/"
    string name = 3;                   // [required] Unique filename including extension. Example: "DN1302M03R16_MERGED_KPSDM_00-32_DEG_T.sgy". The name must be unique across buckets and can be used to identify this file in query requests
    map<string, string> metadata = 4;  // [optional]
    CRS crs = 5;                       // [required] Official name of the CRS used. Example: "EPSG:23031"
    HeaderOffsets header_offsets = 6;  // Byte offsets for headers
    ExternalId external_id = 7;        // [optional] An external identifier - matches service contract field
}


message IngestFileRequest {
    // [required] Either name or id of a file previously registered with /RegisterFile
    // We do not use the (v1) Identifier message because files have string ids.
    // We don't use the (v0) Identifier message because of issues with namespaces in protobuf
    oneof file {
        string name = 1;
        string id = 2;
    }

    /**
        [optional] Selected step to start ingestion. Leave blank to start from last completed step.
        [Accepted values]
           1 -- insert binary and text headers
           2 -- insert trace headers
           3 -- insert trace data
           4 -- compute coverage polygon and additional metadata (trace count, valid lines, etc)
           6 -- insert trace offset indices
        [Use cases]
        * Usual ingestion:
           If the last successful step was 0 (REGISTER), the file will be fully ingested regardless of start_step
        * Completing a failed ingestion:
           If the last successful step was 3 (INSERT_DATA), and no start step is selected, only coverage will be
           computed. Previously ingested headers and traces will be preserved in this case.
        * Forcing reingestion:
           If start_step is 1 (INSERT_FILE_HEADERS), regardless of previous ingestion status, all headers
           and data will be deleted and the whole file will be forcefully reingested
        * Forcing a single step to be rerun:
           If the file is ingested (last step is COMPUTE_COVERAGE), by using start_step = 4 (COMPUTE_COVERAGE),
           for example, only coverage will be computed while headers and traces will be preserved
    **/
    FileStep start_step = 3;

    /**
        [optional as of 2020-11-01, will be required at some later time]
        Target storage tier for this file. If empty a bigtable-based storage will be used.

        A storage tier is a defined facility for storing the trace data associated with a seismic volume.
        The default storage facility is based on Cloud Bigtable, but it is also possible to leave trace data stored
        in SEG-Y files in Cloud Storage, only retaining a compact index of file data in fast storage to facilitate
        retrieval of data from Cloud Storage in a performant manner.

        [Accepted values]
        Accepted values are defined by the tenant configuration, and allow for optimizing tradeoffs between storage
        cost, retrieval performance, numeric precision and sampling.

        Note that currently only one storage tier per trace store is supported, so ingesting an already ingested file
        will result in the file's data being removed from the previously active storage tier.
    **/
    string target_storage_tier_name = 4;
}

message IngestFileResponse {
    string job_id = 1;
}
