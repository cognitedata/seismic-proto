/**
Messages that describe requests/responses from the Seismic Datastore in Cognite Data Fusion
*/
syntax = "proto3";
package com.cognite.seismic.v1;

import "google/protobuf/wrappers.proto";
import "google/protobuf/timestamp.proto";
import "cognite/seismic/protos/v1/seismic_service_datatypes.proto";
import "cognite/seismic/protos/types.proto";

// ---

// Iteration: 9 <- increment this number when you modify this file
// (╯°□°)╯︵ ┻━┻

/**
    Surveys
**/

message CreateSurveyRequest {
    // Short descriptive name
    string name = 1;
    // Key-value pairs of metadata for the survey.
    map<string, string> metadata = 2;
    // Identifier for correlation with systems outside CDF
    ExternalId external_id = 3;
    string crs = 4; // CRS used by all members
    SurveyGridTransformation grid_transformation = 5; // Optional
    CustomSurveyCoverage custom_coverage = 6; // [optional] Customer-provided survey coverage
}

message SearchSurveysRequest {
    repeated SearchSpec surveys = 1; // Optional identifier of the survey. If empty, retrieve all accessible surveys
    bool list_seismic_ids = 2;           // set to true to list the survey's seismics in the response (default: false)
    bool list_seismic_store_ids = 3;  // Set to true to list the survey's seismic stores in the response. Only tenant users can see this.
    bool include_metadata = 4;       // set to true to include survey metadata in the response (default: false)
    CoverageParameters include_coverage = 5;    // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 9;    // set this field to include coverage in the response (default: No coverage)
    bool include_grid_transformation = 6;    // set this field to include the manually specified grid transformation in the response (default: false)
    bool include_custom_coverage = 7;    // set this field to include the customer-provided survey coverage in the response
    // Requests that a coverage geometry from a particular source is returned in the SearchSurveysResponse.
    // If this field is specified, the coverage parameters in the include_coverage field must also be set.
    // Note that this is independent from the custom coverage returned as part of the survey.
    // If no coverage source is provided, but the coverage parameters are provided, the coverage geometry will be fetched from the custom coverage if one has been provided, and the calculated coverage in other cases.
    SurveyCoverageSource coverage_source = 8;
    LastModifiedFilter last_modified = 10; // If set, will further filter returned objects by last modified.
}

message SearchSurveyResponse {
    Survey survey = 1;
    repeated string seismic_ids = 2;  // Optionally present
    repeated string seismic_store_ids = 3;  // Optionally present
    Geometry coverage = 4;  // Optionally present
    SurveyCoverageSource coverage_source = 5;
}

message EditSurveyRequest {
    Identifier survey = 1;
    OptionalMap metadata = 2;  // The existing metadata will be replaced with this metadata.
    ExternalId external_id = 3;
    CRS crs = 4; // CRS used by all members
    SurveyGridTransformation grid_transformation = 5; // Optional
    CustomSurveyCoverage custom_coverage = 6; // Optional
    google.protobuf.StringValue new_name = 7; // If provided, the new name of the survey
}

message DeleteSurveyRequest {
    Identifier survey = 1;
}

message DeleteSurveyResponse {
    bool success = 1;
}

/**
    Source Files
**/

message RegisterSourceSegyFileRequest {
    Identifier survey = 1;                     // [required] The survey this source file belongs to
    string path = 2;                           // [required] Path including protocol, bucket, directory structure, and file name. Example: "gs://cognite-seismic-eu/samples/DN1302M03R16_MERGED_KPSDM_00-32_DEG_T.sgy"
    ExternalId external_id = 3;                // [optional] An external identifier - matches service contract field
    map<string, string> metadata = 4;          // [optional] Any custom-defined metadata
    CRS crs = 5;                               // [required] Official name of the CRS used. Example: "EPSG:23031"
    SegyOverrides segy_overrides = 6;          // [optional] Overrides for the source file
    repeated TraceHeaderField key_fields = 7;  // [optional] The trace header fields that will be used as keys for indexing
    Dimensions dimensions = 8;                 // [required] File data dimensionality, either 2D or 3D
}

message RegisterSourceSegyFileResponse {
    SourceSegyFile file = 1;
}

message EditSourceSegyFileRequest {
    Identifier file = 1;                       // [required] The registered source file to edit
    google.protobuf.StringValue path = 2;      // [optional] Path including protocol, bucket, directory structure, and file name. Example: "gs://cognite-seismic-eu/samples/DN1302M03R16_MERGED_KPSDM_00-32_DEG_T.sgy"
    ExternalId external_id = 3;                // [optional] An external identifier - matches service contract field
    map<string, string> metadata = 4;          // [optional] Any custom-defined metadata
    CRS crs = 5;                               // [optional] Official name of the CRS used. Example: "EPSG:23031"
    SegyOverrides segy_overrides = 6;          // [optional] Overrides for the source file
    repeated TraceHeaderField key_fields = 7;  // [optional] The trace header fields that will be used as keys for indexing
    Dimensions dimensions = 8;                 // [optional] File data dimensionality, either 2D or 3D
}

message EditSourceSegyFileResponse {
    SourceSegyFile file = 1;
}

message UnregisterSourceSegyFileRequest {
    Identifier file = 1;                       // [required] The file to unregister
}

message UnregisterSourceSegyFileResponse {}

message IngestSourceSegyFileRequest {
    Identifier file = 1;                       // [required] The file to queue for ingestiong
    /**
        [required]
        Target storage tier for this file.

        A storage tier is a defined facility for storing the trace data associated with a seismic volume.

        [Accepted values]
        Accepted values are defined by the tenant configuration, and allow for optimizing tradeoffs between storage
        cost, retrieval performance, numeric precision and sampling.

        Note that currently only one storage tier per trace store is supported, so ingesting an already ingested file
        will result in the file's data being removed from the previously active storage tier.
    **/
    string target_storage_tier_name = 2;
}

message IngestSourceSegyFileResponse {
    string job_id = 1;
}

/**
    Seismics
**/

message CreateSeismicRequest {
    string name = 1;  // optional
    string external_id = 2;  // not optional
    Identifier partition = 3;
    int64 seismic_store_id = 4;
    // Defines the portion of the tracestore volume to limit the new seismic to
    oneof volume {
        VolumeDef volume_def = 5;  // Define the volume as VolumeDef format
        Geometry geometry = 7;  // Defines the volume as WKT or GeoJson
        bool empty = 10;  // If true, will create a seismic with an empty cutout
        Seismic2dExtent two_dee_extent = 12;   // only valid if the seismic is 2D
        Seismic3dExtent three_dee_extent = 13; // only valid if the seismic is 3D
    }
    OptionalMap metadata = 6;
    TextHeader text_header = 8;  // Optionally set a custom text header
    BinaryHeader binary_header = 9;  // Optionally set a custom binary header
    bool copy_metadata = 11;  // If true, copy the metadata from the source seismic store.
}

message SearchSeismicsRequest {
    oneof findby {
        SearchSpec survey = 1;
        SearchSpec seismic = 2;
        SearchSpec partition = 3;  // Can only search on partitions you can see.
        SearchSpec seismic_store = 15;  // Must be a data manager to search by seismic store.
        LastModifiedFilter last_modified = 16; // Search for seismics by last modified
    }
    bool include_text_header = 4;
    bool include_binary_header = 5;
    bool include_line_range = 6;
    bool include_volume_definition = 7;  // If true, include the volume definition
    bool include_cutout = 12;            // If true, include the cutout specification the seismic was created with
    bool include_extent = 13;            // If true, include a description of the included traces
    // If specified, indicates which trace header the extent should be indexed by (if a 2d header), or
    // which should be the major direction (if a 3d header). Leaving this unspecified with
    // `include_extent=true` means the server chooses the native key header for each seismic.
    // Any seismic not indexed by the given header will have its extent field left as null.
    TraceHeaderField extent_key = 14;
    bool include_seismic_store = 8;      // If true, include info on the backing seismicstore. Must be data manager.
    bool include_partition = 9;          // If true, include info on the partition. Must be data manager.\
    bool include_coverage = 10;          // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 11;          // If specified, requests coverage as well.
}

message EditSeismicRequest {
    Identifier seismic = 1;
    google.protobuf.StringValue name = 2;
    OptionalMap metadata = 3;
    TextHeader text_header = 4;  // Replaces the existing text header, if specified
    BinaryHeader binary_header = 5; // Replaces the existing binary header, if specified
}

message DeleteSeismicRequest {
    Identifier seismic = 1;
}

message DeleteSeismicResponse {
    bool succeeded = 1;
}

message SearchSeismicStoresRequest {
    oneof findby {
        SearchSpec seismic_store = 1;
        SearchSpec survey = 6;
        SearchSpec file = 8;
        LastModifiedFilter last_modified = 11; // Will return seismic stores by last modified.
    }
    bool include_file_info = 2;  // If true, include File information in the response
    bool include_volume_definitions = 3; // If true, includes inline/crossline volume definitions for store
    bool include_extent = 9; // If true, include a description of the traces contained in the seismicstore
    // If specified, indicates which trace header the extent should be indexed by (if a 2d header), or
    // which should be the major direction (if a 3d header). Leaving this unspecified with
    // `include_extent=true` means the server chooses a key header for each seismicstore.
    // Any seismicstores not indexed by the given header will have its extent field left as null.
    TraceHeaderField extent_key = 10;
    bool include_headers = 5; // if true, include text and binary headers in the response
    bool include_coverage = 4; // Deprecated. Use `coverage` instead.
    CoverageSpec coverage = 7; // If specified, include coverage
}

message InspectIngestionRequest {
    oneof identifier {
        int64 seismic_store_id = 1;
        int64 file_id = 2;
        string job_id = 3;
    }
}

message InspectIngestionResponse {
    SeismicStore seismic_store = 1;
}

message EditSeismicStoreRequest {
    int64 seismic_store_id = 1; // Deprecated. Use `identifier` instead.
    google.protobuf.StringValue name = 2; // If not null will change the seismic store name
    OptionalMap metadata = 3; // If not null, will replace the seismic store metadata
    Identifier seismic_store = 4; // Uniquely identifies one seismic store
    google.protobuf.StringValue external_id = 5; // If not null, will attempt to change the seismic store external id. Can fail if the new external id is not unique.
}

message DeleteSeismicStoreRequest {
    Identifier seismic_store = 1;
}

message DeleteSeismicStoreResponse {
    bool succeeded = 1;
}

/**

    Partitions

**/

message CreatePartitionRequest {
    string name = 1;  // optional name
    string external_id = 2;  // not optional externalid
}

message SearchPartitionsRequest {
    oneof searchspec {
        SearchSpec partitions = 1;
        LastModifiedFilter last_modified = 2; // Search for partitions by last modified.
    }
}

message EditPartitionRequest {
    Identifier partition = 1;  // Must uniquely identify a partition
    string new_name = 2;
}

message DeletePartitionRequest {
    Identifier partition = 1;
}

message DeletePartitionResponse {
    bool success = 1;
}

/**
    Trace querying
**/

message VolumeRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;  // Need to be a data manager or tenant user, not 3rd party, to access by tracestore
    }
    oneof filter {
        LineBasedVolume volume = 3;
        GeometryBasedVolume geometry = 5;
    }
    bool include_trace_header = 4;
}

message GeometryBasedVolume {
    Geometry geometry = 1;
    InterpolationMethod interpolation_method = 2; // Required if the geometry describes a line, otherwise ignored
    LineDescriptor z_range = 3;
}

message VolumeBoundsResponse {
    int32 trace_size_bytes = 1; // The size in bytes of one Trace message
    int32 num_traces = 2;       // The number of traces returned
    int32 sample_count = 5;     // The number of samples per trace
    string crs = 3;             // CRS of the returned trace coordinates
    // Upper and lower bounds and step sizes in each direction for the returned traces.
    // Null if the result is empty. The iline and xline fields will be null for a line-like geometry.
    LineBasedVolume bounds = 4;
}

message StreamTracesRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;  // Need to be a data manager or tenant user, not 3rd party, to access by tracestore
    }
    oneof filter {
        Seismic2dExtent two_dee_extent = 3;   // only valid if the queried object is 2D
        Seismic3dExtent three_dee_extent = 4; // only valid if the queried object is 3D
        GeometryFilter geometry = 5;
    }
    LineDescriptor z_range = 6;
    bool include_trace_header = 7;
}

message TraceBounds {
    int32 trace_size_bytes = 1;     // The size in bytes of one Trace message
    int32 num_traces = 2;           // The number of traces returned
    int32 sample_count = 3;         // The number of samples per trace
    string crs = 4;                 // CRS of the returned trace coordinates
    LineDescriptor z_range = 5;     // The actual range of z values returned
    oneof bounds {
        cognite.seismic.v1.LineRange three_dee_bounds = 6; // Will be null for a line-like geometry
        TwoDeeBounds two_dee_bounds = 7;
    }
}

message TwoDeeBounds {
    // A range bounding the trace header values of the returned traces,
    // using the trace key specified in the extent (if any), or CDP if no extent was specified
    Seismic2dRange requested_bounds = 1;
    LineDescriptor cdp_bounds = 2;  // A range bounding the CDP numbers of the returned traces
}

message SegYSeismicRequest {
    oneof identifier {
        Identifier seismic = 1;
        int64 seismic_store_id = 2;  // Need to be a data manager or tenant user, not 3rd party, to access by seismic store
    }
    oneof query {
        Geometry polygon = 3;
        LineBasedRectangle lines = 4;         // Only valid if the queried object is 3D. Deprecated. Use three_dee_extent instead.
        Seismic2dExtent two_dee_extent = 5;   // Only valid if the queried object is 2D
        Seismic3dExtent three_dee_extent = 6; // Only valid if the queried object is 3D
    }
    int32 skip_message_count = 7; // Skip the first n chunks of the download. Useful for resuming aborted downloads. Default: 0.
}

message SegYSeismicResponse {
    bytes content = 1;
}

/**

    File operations

**/

// Used to search files by a given file/seismic-store/survey search specification
message SearchFilesRequest {
    oneof findby {
        SearchSpec spec = 1;            // Find files using a file search specification
        SearchSpec seismic_store = 2;   // Find files using a seismic store search specification
        SearchSpec survey = 3;          // Find files using a survey search specification
        LastModifiedFilter last_modified = 4; // Filter files by last modified.
    }
}

message SearchJobStatusRequest {
    oneof id {
        string job_id = 1;
        string file_uuid = 2;
        int64 file_id = 9;
    }
    JobStatus status = 3;
    google.protobuf.StringValue target_storage_tier_name = 4;
    google.protobuf.Timestamp started_before = 5;
    google.protobuf.Timestamp started_after = 6;
    google.protobuf.Timestamp updated_before = 7;
    google.protobuf.Timestamp updated_after = 8;
}

message JobStatusResponse {
    string job_id = 1;
    string file_uuid = 2;
    JobStatus status = 3;
    google.protobuf.Timestamp started_at = 4;
    google.protobuf.Timestamp updated_at = 5;
    google.protobuf.StringValue target_storage_tier_name = 6;
    repeated IngestionLog logs = 7;
    int64 file_id = 8;
}

message IngestionLog {
    google.protobuf.Timestamp timestamp = 1;
    string log_line = 2;
}
